/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_endswith.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: seojepar <seojepar@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/13 17:56:45 by seojepar          #+#    #+#             */
/*   Updated: 2024/11/18 18:27:58 by seojepar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"

/* 생각1
- string A,B에 대해서, A의 끝이 B로 끝나는 유무 반환하는 함수
    생각. 1. 길이 비교해서 B가 더 길면 반환? ㄴㄴ 그러면 두번 돌게 됨.
    그냥, 뒤에서부터 순회하면서 계속 같으면 true, 아니면 false 반환하게 하자.
    컴파일 에러 날 경우: a와 b 자체가 널 포인터라 참조가 불가능한 경우

    구현. B의 맨 뒤에서부터 돌려면 어차피 길이를 한번 측정해야함.
    그럴꺼면 그냥 strlen을 써야하네..
    어떻게 해야하지..?

    이래서 나같아도 C++에서 string 이라는 클래스를 만들었다.
    애초에 만들때부터 어차피 한번씩 순회하는거면 그 길이를 저장해놨다가 요긴하게 이럴떄 쓸 수가 있다.
    진짜 존나 비효율적인 코드가 만들어진다. C 만 사용하면.
    방법1. 앞에서부터 일치하는지 확인한다. A * B (길이를 따졌을 때)
    방법2. 길이를 한번 재고, 뒤에서만 체크한다. A + B + B
    방법3. 모르겠다.

    방법2로 간택당하였다.

    여기서 구현하다가 약간 드는 의문은, strlen을 구현하는데 libft 에 의존성을 넣기 싫어서, 
    size_t strlen을 만들려다가 size_t가 정의되지 않아서 그냥 int로 했다.
    만약 근데 길이가 int 범위를 벗어나면 어떻게 되는거지?
*/
/* 생각2
    엣지케이스(널) - 바로 false 리턴
    코드를 머릿속으로만 생각하고 짜다보니까 막 막힌다. (어떤 조건일때 그래서 참인지)
    sol1:
    1. a와 b를 맨 뒤로 옮긴다.
    2. 뒤에서부터 앞으로 옮기면서 모든 캐릭터가 일치하는지 확인한다.  
    prob: 탈출조건(b 맨 앞 도달) 계산하려면 b의 길이를 저장해야함.
    > sol2:
    1. a를 a의 길이 - b의 길이의 위치로 옮긴다. (1 차이 날 수도)
        예시: "baase" "se" 길이 5 2 > 3부터 검사하는게 맞다.
        prob: 만약, b의 길이가 더 길다면..? 컴파일 에러 (X)
        이 방법이 더 불완전한 것 같다. sol1으로. 가려고 했으나, 다시 생각하니 이게 더 나음
        따로 처리해주면 된다. (O)
    2. 앞에서부터 증가시키면서 비교한다. b가 널 도달시 종료.
    
    sol1을 택하고 코드의 가독성을 더 높일 수 있는 방법이 있을 텐데 모르겠다.
    근데 곰곰히 생각해보니 너무 복잡한거 같아서 그냥 sol2를 하되 예외처리를 해주는 방식으로 가려고 한다.
 */

int ft_endswith(char *a, char *b)
{
    int dl;

    if (!a || !b)
        return (0);
    dl = ft_strlen(a) - ft_strlen(b);
    if (dl < 0)
        return (0);
    a += dl;
    while (*a && *a == *b)
    {
        a++;
        b++;
    }
    return (*a == '\0');
}

// #include <stdio.h>
// int main()
// {
//     printf("%d\n", ft_endswith("teststring", "string"));
//     printf("%d\n", ft_endswith("teststring", "str"));
//     printf("%d\n", ft_endswith("teststring", ""));
//     printf("%d\n", ft_endswith("teststring", "a"));
//     printf("%d\n", ft_endswith("", "hihi"));
// }


